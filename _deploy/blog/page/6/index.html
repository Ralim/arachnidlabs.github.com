<!DOCTYPE html>
<html>	
	<head>

		<meta name="description" content="Makers of fine electronics since 2013.">
		<meta http-equiv='Content-Type' content='text/html; charset=utf-8' />
		
		<title></title>

		<link rel="stylesheet" type="text/css" href="/css/style.css">
		<link rel="stylesheet" type="text/css" href="/css/normalize.css">
		<link rel="stylesheet" href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css">
		<link rel="stylesheet" type="text/css" href="/css/animate.css">
		<link rel="alternate" type="application/rss+xml" title="Arachnid Labs" href="http://www.arachnidlabs.com/atom.xml" />
	
		<link rel="icon" type="image/png" href="/favicon.png">

		<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js"></script>
		<script type="text/javascript" src="/js/jquery.sticky.js"></script>
		<script type="text/javascript" src="/js/masonry.pkgd.min.js"></script>
		<script type="text/javascript" src="/js/wow.min.js"></script>

		<script>
  			$(document).ready(function(){
    			$("#nav").sticky({topSpacing:0});
  			});
		</script>

		<script type="text/javascript">
			var wow = new WOW(
			  {
			    boxClass:     'wow',      // animated element css class (default is wow)
			    animateClass: 'animated', // animation css class (default is animated)
			    offset:       0,          // distance to the element when triggering the animation (default is 0)
			    mobile:       true,       // trigger animations on mobile devices (default is true)
			    live:         true        // act on asynchronously loaded content (default is true)
			  }
			);
			wow.init();
		</script>

		<!-- If the browser version of IE is less than 9 load HTML5 & CSS3 polyfills -->
        <!--[if lt IE 9]>
            <link rel="stylesheet" href="css/ie.css">
            <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script>
            <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/selectivizr/1.0.2/selectivizr-min.js"></script>
        <![endif]-->

	</head>
	<body>

		<div class="intro">
			
			<div class="center">
				<img src="/images/arachnidlabs.svg">

				<ul class="social">
					<li><a href="https://github.com/arachnidlabs"><i class="fa fa-github"></i></a></li>
					<li><a href="https://twitter.com/arachnidlabs"><i class="fa fa-twitter"></i></a></li>
<!--					<li><a href=""><i class="fa fa-youtube-play"></i></a></li>-->
					<li><a href="https://plus.google.com/+Arachnidlabs/"><i class="fa fa-google-plus"></i></a></li>
				</ul>

			</div>

		</div>

		<div id="nav" class="clearfix">
			
			<div class="wrapper">
				
				<div class="logo">
					
					<h1></h1>

				</div>

				<nav>
					
					<ul class="clearfix">
						<li><a href="/index.html">Home</a></li>
						<li><a href="https://www.tindie.com/stores/arachnidlabs/">Shop</a></li>
						
							
							
							
						
							
							
							
						
							
							
							
						
							
							
							
						
							
							
							
						
							
							
							
						
							
							
							
						
							
							
							
						
							
							
							
								<li><a href="/about/index.html">About</a></li>
							
						
							
							
							
								<li><a href="/labs-cards/index.html">Circuit pattern trading cards</a></li>
							
						
							
							
							
								<li><a href="/reload-2/index.html">Re:load 2</a></li>
							
						
							
							
							
								<li><a href="/reload-pro/index.html">Re:load Pro</a></li>
							
						
							
							
							
						
							
							
							
						
							
							
							
								<li><a href="/minishift/index.html">Minishift</a></li>
							
						
							
							
							
						
							
							
							
						
							
							
							
						
							
							
							
						
							
							
							
						
							
							
							
						
							
							
							
						
							
							
							
						
							
							
							
						
							
							
							
						
							
							
							
						
							
							
							
						
							
							
							
						
							
							
							
						
							
							
							
						
							
							
							
						
							
							
							
						
							
							
							
						
							
							
							
						
					</ul>

				</nav>
				
			</div>

		</div>

		<div class="container">
			



<div class="posts">
	

	<div onclick="window.location.href='/blog/2013/02/04/constant-current-plank/'" class="mypost wow clearfix ">
	   	<div class="date">
	   		<p class='date-top'>4</p><p class='bottom-date'>Feb 2013</p>
	   	</div>
	  	<div class="postcontent">
	  		<h1>Constant Current Plank</h1>
	    	
    			<p>As mentioned in a previous progress update post, I’ve been working with Firehopper, from the <a href="http://webchat.freenode.net/?channels=sparkfun">#sparkfun</a> channel on freenode, to design a constant current plank, aimed at driving high powered LEDs. It’s just about done, with only some minor silkscreen issues to go.</p>

<p><img src="https://github.com/arachnidlabs/loki/blob/master/schematics/currentplank/currentplank-layout.png?raw=true" alt="" /></p>

<p>The board makes use of two <a href="http://www.st.com/internet/com/TECHNICAL_RESOURCES/TECHNICAL_LITERATURE/DATASHEET/CD00185795.pdf">STCS2A</a> constant current driver ICs from ST Micro, in PowerSO form (an SOIC outline with a thermal pad on the bottom). Each is capable of controlling up to 2A at up to 40V. They support PWM - which is hooked up to Loki GPIO pins, naturally - a fault indicator for when there is no load present, and their maximum current is configurable via a shunt resistor.</p>

<p>The use of a shunt is actually somewhat inconvenient, since it makes adjusting the current limit awkward. There aren’t a great number of 0.1 ohm potentiometers that can handle 2A out there. Instead, we’ve gone with a slightly more complex solution, involving an opamp. A potentiometer in a voltage divider configuration provides a reference voltage; one opamp per channel attempts to make the shunt voltage equal to that, by feedback through the controller’s sense pin. This will make it easy to tweak the current limit at runtime with a single potentiometer. PWM still makes it possible to individually dim each channel from the MCU, of course.</p>

<p>The provision of a PWM pin makes this board a perfect fit for the PSoC’s built in lighting controller module, the <a href="http://www.cypress.com/?rID=48890">PrISM</a>. Instead of using PWM like regular controllers, PrISM uses a random sequence generator hooked up to a comparator. Each step, the value in the comparator is compared to a generated value, and the output goes high if it’s higher, and low otherwise. The result is much like PWM, but with the significant advantage that you can update the compare value at any time without glitches, and the effective illumination will quickly and smoothly adjust to the new value.</p>

<p>I’m quite pleased with the layout on this board, too. I’ve been trying pay more attention to the attractiveness of PCB layouts recently, after seeing some really nice ones in <a href="http://webchat.freenode.net/?channels=hackvana">#hackvana</a> on freenode. A symmetrical and well laid out PCB looks a lot more attractive than one with parts all over the place, and I think I’ve done a pretty good job here.</p>

			
	    	<p class="readmore">
	      		<a href="/blog/2013/02/04/constant-current-plank/">Read Post</a>
	    	</p>
	  	</div>

	</div>

	

	<div onclick="window.location.href='/blog/2013/02/01/the-loki-motor-plank/'" class="mypost wow clearfix ">
	   	<div class="date">
	   		<p class='date-top'>1</p><p class='bottom-date'>Feb 2013</p>
	   	</div>
	  	<div class="postcontent">
	  		<h1>The Loki Motor Plank</h1>
	    	
    			<p>Last of the initial set of Loki planks - but certainly not least - I present the Loki Motor Plank:</p>

<p><img src="https://lh5.googleusercontent.com/-QQby0ZFF-Ns/UQxDbCFsXeI/AAAAAAAACcc/FlMHnQw8qOw/w397-h298-n-k/P1010198.JPG" alt="" /></p>

<p>The Motor Plank is a straightforward DC motor driver utilizing the <a href="https://www.pololu.com/file/download/TB6612FNG.pdf?file_id=0J86">TB6612FNG</a> dual H-Bridge motor driver. It’s capable of driving two DC motors at up to 1.2A each - or you can parallel it to drive a single motor at a higher current.</p>

<p>The board uses six GPIO pins, for the A, B and PWM inputs on each H-Bridge. The board features screw terminals for the motors and optional DC power in, and bicolor LEDs to indicate motor speed and direction. An optional jumper allows you to connect the motor driver’s power rail to the Loki’s VIN terminal. This gives you the flexibility of powering the motors straight from the Loki if using a DC adaptor and low power motors, powering the Loki from the motor driver screw terminals, or of having two entirely separate supplies for motor and Loki.</p>

<p>The plank’s naturally pretty straightforward to operate: simply set the A and B inputs for the desired direction of motion on each motor, and PWM the PWM pins to control motor speed.</p>

<p>Of course, the Loki’s flexibility when it comes to GPIO and peripherals makes it easy to implement motor driving schemes other than Sign-Magnitude; I look forward to seeing someone implement <a href="http://modularcircuits.tantosonline.com/blog/articles/h-bridge-secrets/lock-anti-phase-drive/">Locked Anti-Phase Drive</a> with no CPU overhead!</p>

			
	    	<p class="readmore">
	      		<a href="/blog/2013/02/01/the-loki-motor-plank/">Read Post</a>
	    	</p>
	  	</div>

	</div>

	

	<div onclick="window.location.href='/blog/2013/01/31/daily-progress-report/'" class="mypost wow clearfix ">
	   	<div class="date">
	   		<p class='date-top'>31</p><p class='bottom-date'>Jan 2013</p>
	   	</div>
	  	<div class="postcontent">
	  		<h1>Daily progress report</h1>
	    	
    			<p>I spent this evening polishing off the library code for the component to drive the Nokia display, and porting the Game of Life demo to it. Users will now have a nice convenient packaged library for using the display, with no knowledge of its wire protocol required. Data is transferred to the screen using DMA, so you can update the whole screen with no involvement at all from the CPU, making it a very efficient process. I still need to write up some documentation for the library and the Game of Life project. I’d also like to enhance the library component to add at least basic text support, so people don’t have to cook up their own solution.</p>

<p>I’ve also moved the official Loki source repository to the Arachnid Labs github account; you can find it <a href="https://github.com/arachnidlabs/loki/">here</a>. All the schematics for the Loki and the expansion boards, the demo code, dimensional drawings, the bootloader host code, and so forth can be found there. The only component that is not yet in the repository is the bootloader code; it will be added shortly. Everything I can make OSS in this project, I will make - no ‘secret sauce’ held back!</p>

<p>Finally, I’ve started working with Firehopper, a denizen of the #sparkfun IRC channel on freenode, to design another Loki expansion plank. This one’s a constant current driver plank, capable of driving up to 2A on two separate channels and PWM dimmable, designed for high power LEDs. Keep an eye out for an intro to it soon!</p>

			
	    	<p class="readmore">
	      		<a href="/blog/2013/01/31/daily-progress-report/">Read Post</a>
	    	</p>
	  	</div>

	</div>

	

	<div onclick="window.location.href='/blog/2013/01/30/the-loki-prototyping-plank/'" class="mypost wow clearfix ">
	   	<div class="date">
	   		<p class='date-top'>30</p><p class='bottom-date'>Jan 2013</p>
	   	</div>
	  	<div class="postcontent">
	  		<h1>The Loki Prototyping Plank</h1>
	    	
    			<p>Time to introduce another of the initial set of Loki planks, the Prototyping Plank.</p>

<p><img src="https://lh6.googleusercontent.com/-zFjuUYM3EuY/UQLmE8DQ6xI/AAAAAAAACbA/GTw7VeHznYU/w268-h201-n-k/P1010191.JPG" alt="" /></p>

<p>Every platform needs a prototyping board, and Loki’s no exception. It may not be exciting, but it’s certainly essential.</p>

<p>Besides the expected grid of prototyping holes, this one has some important features:</p>

<ul>
  <li>Breaks out 8 GPIO lines</li>
  <li>Dedicated area for thru-hole DIP chips up to 24 pins wide</li>
  <li>Convenient 3v3 power and gnd buses</li>
  <li>General prototyping area</li>
  <li>Square pads for easy soldering of SMT passives</li>
  <li>Dedicated area for right-angle edge connectors on the left side of the board</li>
  <li>Breaks out all power/config header pins</li>
</ul>

<p>There’s not a great deal else to say about this one. I’m certain people will find it useful, though.</p>


			
	    	<p class="readmore">
	      		<a href="/blog/2013/01/30/the-loki-prototyping-plank/">Read Post</a>
	    	</p>
	  	</div>

	</div>

	

	<div onclick="window.location.href='/blog/2013/01/29/display-plank-demo-conways-game-of-life/'" class="mypost wow clearfix ">
	   	<div class="date">
	   		<p class='date-top'>29</p><p class='bottom-date'>Jan 2013</p>
	   	</div>
	  	<div class="postcontent">
	  		<h1>Display Plank demo: Conway's Game of Life</h1>
	    	
    			<p>Just a short post today. I’ve been writing some libraries and demo apps for the Loki, and first up is the Display Plank. Here’s a quick demo showing it running Conway’s Game of Life:</p>

<iframe width="640" height="360" src="http://www.youtube.com/embed/i93JgOgLXc0" frameborder="0" allowfullscreen=""></iframe>

<p>That’s running at nothing like full speed - I slowed it down a lot so us mere humans could comprehend it.</p>

<p>This was just hacked up in a hurry, but I’m currently working on a library for the display so it’ll be really easy to use in your own projects. It’ll make use of the PSoC’s DMA facilities, so it will be a lot more efficient, too - just pass in a buffer representing the display, and it will write the whole thing out to the display with no involvement from your code or the CPU.</p>

<p>Keep an eye out for more details on the peripheral and the inner workings of the demo soon!</p>

			
	    	<p class="readmore">
	      		<a href="/blog/2013/01/29/display-plank-demo-conways-game-of-life/">Read Post</a>
	    	</p>
	  	</div>

	</div>

	

	<div onclick="window.location.href='/blog/2013/01/28/plug-and-play-configuration-with-loki/'" class="mypost wow clearfix ">
	   	<div class="date">
	   		<p class='date-top'>28</p><p class='bottom-date'>Jan 2013</p>
	   	</div>
	  	<div class="postcontent">
	  		<h1>Plug and Play configuration with Loki</h1>
	    	
    			<p><a href="/blog/2013/01/24/how-loki-avoids-pin-conflicts/">Previously</a>, I wrote about how Loki avoids pin conflicts by remapping IO pins with surface mount headers on each expansion plank. I mentioned at the time that this can lead to some confusion figuring out which plank pins correspond to which microcontroller pins, and hinted at a solution. Today, we’ll take a closer look at how that solution works.</p>

<p>The problem, if you recall, is that the Loki is set up such that each plank takes the first available pins; this means that the microcontroller pins your plank is connected to depend on what other planks are in the stack below it. Rearrange the planks, and the pin assignments change. This isn’t a problem from a hardware point of view - any Loki pin can perform any function - but it can be hard to keep track of.</p>

<p>Loki solves this with a configuration system. Much like the Beaglebone, each expansion plank has an onboard EEPROM that contains configuration data. This data includes its name URL, optional serial number, flags, and most importantly, a description of which GPIO pins it uses. Each pin that’s used is given a name determined by the plank. Likewise, the Loki has an onboard EEPROM storing the pin names of the Loki itself.</p>

<p>With EEPROMs on each plank, we can identify planks at runtime, and with the pin names on the Loki and the pin names on the expansion boards, we can build up a nice convenient table, allowing users to see at a glance which pin is mapped to which plank. This still ignores the sticky issue of addressing, however. Supposing we use I2C EEPROMs - how do we ensure each plank’s EEPROM has a unique (and predictable) address? We could use jumpers, like BeagleBone capes do, but this seems rather manual. The consequences of setting the jumpers wrong are a lot worse for the Loki than they would be on the Beaglebone, too - the pin mappings would be inaccurate. How can we give each EEPROM a unique address, without manual intervention and undue complexity?</p>

<p>The answer comes to us from computer science, in the form of the <a href="http://en.wikipedia.org/wiki/LFSR">Linear Feedback Shift Register</a> or LFSR. An LFSR is a way to generate a sequence of numbers that goes as long as possible without repeating. Even better, LFSRs are really simple to generate, and can be made using a single XOR operation to generate each subsequent bit!</p>

<p>A concrete example will be more enlightening. Suppose we want to generate all possible 3-bit addresses. A maximum length LFSR for this has 3 bits of state, and generates the next state by taking the two most significant bits and XORing them together. Suppose we start with 001. We XOR the two most significant bits together (0 XOR 0 = 0) and add them to the end, getting a new state of 010. Repeating, we then get 101, 011, 111, 110, 100, 001. Note that we stepped through every single non-zero 3-bit number before coming back to our starting point of 001.</p>

<p>Using this in Loki is quite straightforward. The smaller Loki expansion header has three address pins. On the Loki itself, these are hardwired to 0, 0 and 1. Each plank connects the incoming address pins directly to its EEPROM’s address pins; it also shifts them left by one - so A1 becomes A2 and A0 becomes A1 - and uses a single XOR gate IC, the <a href="http://www.nxp.com/documents/data_sheet/74HC_HCT1G86.pdf">74HC1G86</a> to generate the new A0 by XORing A1 and A2 together. Thus, the next plank in the stack sees the next value in the sequence, ensuring we can stack up to 7 planks without any repeating addresses. The XOR IC and the EEPROM (a <a href="http://www.onsemi.com/pub_link/Collateral/CAT24C32-D.PDF">CAT24C32</a> or larger) together cost less than $0.50 in quantity, so this adds a negligible cost to the average expansion plank. Here’s an example schematic for the relevant part of an expansion plank:</p>

<p><img src="https://lh4.googleusercontent.com/1nT5oD77_QteH6qhmQM9W_kFVk6sfqL5uQ_tRlcDJEyFcrFz4o5VJLTz9AMn7efEExYBpKiVSRxk_D0fytjXx6g5wRlB15nXlf7_DvPk4bGnBQ6cDi9R" alt="" /></p>

<p>This system has incidental benefits as well. In addition to providing a general purpose I2C bus to all planks independent of the GPIO pins, it also provides a way for planks to attach to it without risk of address conflicts. As long as the I2C ICs they use have a different fixed prefix to the EEPROMs (which use the 7-bit prefix 0x50), they can use the same address pins for their own ICs.</p>

<p>The end result of this is a rather nice plug-and-play system that Just Works. I’m currently working on the bootloader host software, which together with the bootloader, can autodetect all the expansion planks installed on a Loki, and present you with details of each, along with an accurate pin mapping from microcontroller pin to plank pin, with useful pin names. Keep an eye out for a demo of it soon.</p>

			
	    	<p class="readmore">
	      		<a href="/blog/2013/01/28/plug-and-play-configuration-with-loki/">Read Post</a>
	    	</p>
	  	</div>

	</div>

	

	<div onclick="window.location.href='/blog/2013/01/25/the-loki-audio-plank/'" class="mypost wow clearfix ">
	   	<div class="date">
	   		<p class='date-top'>25</p><p class='bottom-date'>Jan 2013</p>
	   	</div>
	  	<div class="postcontent">
	  		<h1>The Loki Sound Plank</h1>
	    	
    			<p>Time for a look at another one of the initial expansion planks for the Loki: The Sound plank.</p>

<p><img src="https://lh3.googleusercontent.com/-97CVCWIpImk/UQLmDzpt3-I/AAAAAAAACa8/k8ygv6WcPkA/w388-h290-n-k/P1010190.JPG" alt="" /></p>

<p>This plank takes advantage of the PSoC processor’s built in analog functionality to offer audio input and output options few microcontroller platforms can offer - at least, not affordably! The plank supports two stereo line jacks - one for line level output, the second for either input or output - and a 1W mono amplifier that can drive small speakers. It also has an IR receiver module as an option.</p>

<p>The plank takes 6 IO lines: Two for each line jack, one for digital volume control of the amplifier, and one for the IR receiver. As you can see from the photo, it doesn’t need very many components at all: a couple of film capacitors on each jack provide DC blocking, while the line in has protection diodes to protect the microcontroller against overvoltage. The amplifier is a single chip, the <a href="http://media.digikey.com/pdf/Data%20Sheets/NXP%20PDFs/TDA7052A_AT.pdf">TDA7052A</a>. It provides a 1 watt mono amplifier with an absolute minimum of external components. The speaker output is provided on a screw terminal at the bottom of the board.</p>

<p>All of this is complemented beautifully by the PSoC’s built in analog features. Analog features vary from chip to chip in the PSoC 5 range, but all have at least one ADC and one DAC; most have 2 or more DACs. In addition, most of the line have configurable analog blocks, which can be configured to act as programmable gain amplifiers and as sample-and-hold units, amongst other functions. Finally, most of the line have dedicated opamps that are accessible both internally on external pins.</p>

<p>When placed at the bottom of the stack, the Sound Plank is configured such that the outputs of two of the dedicated opamps are connected to the line out jack. This means the Loki can provide a very low impedance line output, perfect for good quality audio. Even when elsewhere in the stack, or connected to a processor that does not have dedicated opamps, the built in analog hardware still provides a good analog path.</p>

<p>Once connected, the user has a lot of options. The configurable analog blocks can be set up as sample and hold devices, allowing a single DAC to drive multiple channels, or the outputs can be driven directly from multiple DACs. PWM can even be used, if desired - all configured inside the chip. On the input side, the ADC can be configured to sample alternately from each channel at anything up to 700k samples per second.</p>

<p>All up, the Audio Plank will provide an exceptionally flexible solution for simple audio input and output on the Loki.</p>

			
	    	<p class="readmore">
	      		<a href="/blog/2013/01/25/the-loki-audio-plank/">Read Post</a>
	    	</p>
	  	</div>

	</div>

	

	<div onclick="window.location.href='/blog/2013/01/24/how-loki-avoids-pin-conflicts/'" class="mypost wow clearfix ">
	   	<div class="date">
	   		<p class='date-top'>24</p><p class='bottom-date'>Jan 2013</p>
	   	</div>
	  	<div class="postcontent">
	  		<h1>How Loki avoids pin conflicts</h1>
	    	
    			<p>In <a href="/blog/2013/01/22/introducing-loki/">an earlier post</a>, I mentioned that Loki has a novel way of avoiding the pin conflict issues that plague other stackable expansion board systems. Today we’ll take a closer look at just how that works.</p>

<p><img src="https://lh4.googleusercontent.com/-tsz2IdYroc8/UQGkures4PI/AAAAAAAACY0/2MpcIDu5QBQ/w372-h201-n-k/IMG_20130124_211127.jpg" alt="" /></p>

<p>Most stackable expansion systems, such as Arduino, use long-tail thru-hole headers, that connect directly from the receptacles on the top of the board through to the pins on the bottom. These are convenient - though surprisingly hard to come by - and straightforward, but have a major issue: stacked boards must avoid using the same pins as each other, or they’ll be incompatible. Worse, there’s no good way for a shield designer to pick pins that won’t conflict, other than picking specific other shields to ensure compatibility with. Every user has to check carefully before purchasing a shield to ensure it won’t conflict with the other ones they want to use. Aside from being a hassle, this limits opportunities, making otherwise well suited expansions unusable.</p>

<p>There must be a better way, right? Fortunately, there is, and Loki implements it. Here’s how it works: Instead of using thru-hole stacking headers, Loki uses surface mount headers on the bottom, and surface mount receptacles on the top. Common signals such as power, ground, and the I2C bus are passed straight through, bottom to top. IO pins, however, are handled somewhat differently.</p>

<p>Instead of using any pins, each plank uses the first few pins from the GPIO bank. Then, it routes the remaining pins on the bottom header to the top, shifting them up to fill the ‘gaps’ left by the pins it consumed. So if a plank needs 4 pins, it will use pins 1-4 for itself, then connect the incoming pin number 5 to outgoing pin 1, 6 to 2, 7 to 3, and so forth. In this fashion, because used pins are never passed through, every pin can only ever be used by a single plank, and thus no plank has to worry about conflicts. You can keep stacking additional planks until you run out of IO pins!</p>

<p>Of course, the reality is slightly more complicated than the theory, but only a little. A plank that needs to use a lot of IO pins could have some difficulty cleanly routing the remaining pins to the first headers on the top side, so Loki splits the pins into two independent banks, consisting of the first half and the last half of the pins. A plank must take an equal number of pins from each bank. This simplifies the routing somewhat, while still preserving the flexibility. It’s also possible - though uncommon - for a plank to take pins other than the first ones in a bank. This limits where in the stack the plank can practically be placed, but still works fine: the plank just ‘shifts up’ the remaining pins to fill the gaps.</p>

<p>Here’s an example header layout for a plank that uses one pin from each bank:</p>

<p><img src="https://lh4.googleusercontent.com/88V90srS1O-R4wAI3o6nlAmadROB5Gy5P3il9imbI2CIywJgCogtNdJzANDg-aYfEKl4Qt_v9qjFc1R0cU2FYlaV6zXbr8cMoIJJeL4g-6nERhZwyAz0" alt="" /></p>

<p>As you have no doubt noticed from <a href="https://lh4.googleusercontent.com/-hinotxKY9e4/UP70GQ7E6bI/AAAAAAAACXQ/9lZJ6H0Z7Ww/s884/P1010166.JPG">the photos</a>, Loki has two expansion headers. The one on the top, a 2x16 header, contains all 32 GPIO pins, and uses the scheme described above. The one on the bottom, a 1x10 header, carries the power rails, ground, reset, the hardwired I2C bus, and a few other control signals we’ll go into later.</p>

<p>If you’re curious to learn more, or start planning out your own expansion planks, a preliminary specification for planks is <a href="https://docs.google.com/document/d/1o2kg8sRGAV_mO6ycADnk_pME490gHMmBCJu4eNQzvfI/edit">available here</a>. Beware that it may change before 1.0 - so if you are intending to make a board, <a href="&#109;&#097;&#105;&#108;&#116;&#111;:&#110;&#105;&#099;&#107;&#064;&#097;&#114;&#097;&#099;&#104;&#110;&#105;&#100;&#108;&#097;&#098;&#115;&#046;&#099;&#111;&#109;">get in touch</a> first!</p>

<p>Some of you may be thinking that this system, ingenious though it may be, could lead to some confusion regarding which microcontroller pins are assigned to which plank pins, and you’d be right. Loki has a clever solution to that conundrum too - the details of which will be revealed in a future blog post.</p>

			
	    	<p class="readmore">
	      		<a href="/blog/2013/01/24/how-loki-avoids-pin-conflicts/">Read Post</a>
	    	</p>
	  	</div>

	</div>

	

	<div onclick="window.location.href='/blog/2013/01/23/the-loki-display-plank/'" class="mypost wow clearfix ">
	   	<div class="date">
	   		<p class='date-top'>23</p><p class='bottom-date'>Jan 2013</p>
	   	</div>
	  	<div class="postcontent">
	  		<h1>The Loki Display Plank</h1>
	    	
    			<p>Today we’ll take a quick look at one of Loki’s initial expansion boards, the display plank.</p>

<p><img src="https://lh5.googleusercontent.com/-8P3sEo00Q54/UQLmBVLtCWI/AAAAAAAACa4/O6BAY0AjvCk/w387-h290-n-k/P1010188.JPG" alt="" /></p>

<p>The display plank is a straightforward user interface plank, featuring an 84x48 dot matrix LCD display with backlight, and a 5-way (4 directions plus center click) digital joystick. It takes up 8 GPIO pins from the Loki, and it’s a “top plank”, meaning nothing else can be stacked on top of it.</p>

<p>I wanted this to be a substitute for the expansion boards featured in other embedded systems that feature a 16x2 character display. I figure that a simple graphic LCD will be a lot more interesting and versatile, and no harder to drive with the right libraries.</p>

<p>The display is worth a closer look. It’s an integrated module originally designed for the Nokia 5110 mobile phone, which makes it a bit on the venerable side, but with the significant advantage that it’s now really affordable - in bulk, it can be obtained for less than $1 per display, a price that’s hard to beat. I think of it as the <a href="http://en.wikipedia.org/wiki/Casio_F91W">Casio F91W</a> of displays. Breakout boards are available from places like <a href="https://www.sparkfun.com/products/10168">SparkFun</a>, but I opted to build it directly onto the plank, to save money and improve the form factor.</p>

<p>The integrated controller on the LCD is the PCD8544, and speaks SPI, with an additional command/data selector pin. The protocol is well documented and quite straightforward. One of my first todos after getting the bootloader host finished and the alpha boards made is to write a library for this in PSoC creator, so that the display can simply be memory mapped and written to by blitting directly to memory, which should make using it super-easy.</p>

<p>The display attaches to the board with four metal clips; slots on the plank accommodate these and hold it in place. Electrical connections are via a flexible connector on the back; they simply make contact with bare pads on top of the PCB, no soldering required. If you’re building your own, bear in mind that a standard 1.6mm PCB is far too thick; use 1.0mm FR4 instead.</p>

<p>The display itself doesn’t include the backlight; it’s up to the host to provide that. I’ve done this with four 0805 white LEDs behind the module, which light it up nicely. It’d be easy to trade these out for other colors, too. An n-channel MOSFET gives the Loki control of backlight illumination.</p>

<p>Finally, the joystick. This is a part I picked up in bulk from China, courtesy of a good friend, and it works pretty much how you’d expect: 5 switches, with a common pole between them. The switch is connected with the common pole to ground, and the 5 switches connected directly to Loki IO lines; it’s up to Loki to pull these high using the built in pullups.</p>

<p>All in all, the display plank is a flexible board for basic user interaction, and I hope to be able to provide it at a much lower price than most similar expansion boards using character displays. I think this is going to make for some great demo apps, too - <a href="http://en.wikipedia.org/wiki/Snake_(video_game)">Snake</a>, anyone? If you’ve got an idea for a great way to show the plank off, don’t hesitate to leave a comment, too!</p>


			
	    	<p class="readmore">
	      		<a href="/blog/2013/01/23/the-loki-display-plank/">Read Post</a>
	    	</p>
	  	</div>

	</div>

	

	<div onclick="window.location.href='/blog/2013/01/22/social-media-stuff/'" class="mypost wow clearfix ">
	   	<div class="date">
	   		<p class='date-top'>22</p><p class='bottom-date'>Jan 2013</p>
	   	</div>
	  	<div class="postcontent">
	  		<h1>Social media stuff</h1>
	    	
    			<p>I’ve set up accounts for Arachnid Labs on <a href="https://plus.google.com/102498818006624473472/posts">Google+</a> and <a href="https://twitter.com/ArachnidLabs">Twitter</a>. Follow them if you’d like to keep up to date with Arachnid Labs’ latest developments, and progress on Loki!</p>

			
	    	<p class="readmore">
	      		<a href="/blog/2013/01/22/social-media-stuff/">Read Post</a>
	    	</p>
	  	</div>

	</div>

	
</div>
</div>

	<div class="pagination">
		<div class="innerpagi clearfix">
		  	
		    	<a class="previous" href="/blog/page/5">&laquo; Previous</a>
		  	

		  	
		    	<a class="next" href="/blog/page/7">Next &raquo;</a>
		  	
		</div>
	</div>



		</div>

		<footer class="clearfix">
			<p>2014 &copy Arachnid Labs | Theme designed by <a href="http://www.themeforest.net/user/uziiuzair">Uzair Hayat</a></p>

			<ul class="social">
				<li><a href="https://github.com/arachnidlabs"><i class="fa fa-github"></i></a></li>
				<li><a href="https://twitter.com/arachnidlabs"><i class="fa fa-twitter"></i></a></li>
				<!--<li><a href=""><i class="fa fa-youtube-play"></i></a></li>-->
				<li><a href="https://plus.google.com/+Arachnidlabs/"><i class="fa fa-google-plus"></i></a></li>
			</ul>

		</footer>

		<script type="text/javascript">

		  var _gaq = _gaq || [];
		  _gaq.push(['_setAccount', 'UA-84449-7']);
		  _gaq.push(['_trackPageview']);

		  (function() {
		    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
		    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		  })();

		</script>

	</body>
</html>